### 模块化

近年来，前端越来越流行组件化，这也是一种趋势，组件化复用性高，易于维护，层次清晰。模块化与组件化大同小异，就是将一个个功能抽象成模块，在需要的地方引入使用即可，方便快捷。

但是在js这种语言里面，并没有模块化的机制，也就是说，你定义一个变量

``var a = 0;``

时，js会变量提升，变为全局变量，如果其他地方再定义这个变量的话，就会产生冲突。那如何实现模块化呢？js中有一种我们又爱又恨的东西叫闭包，或者说js是一种函数式编程语言，而函数，是有块级的作用的，也就是一个函数，可以看成是一个模块，在两个不同的函数里面定义相同的变量不会产生冲突，这就是模块化的理论了。

接下来看看node模块化中代码的简单实现：

```javascript
// 准备将模块化的结果实现到对象上
var module = {
    id: 'module_test', // 模块都是单独的
    exports: {} // 一个模块可以有多个方法被暴露出去
};
var load = function (module) {
    // 获取模块里面的方法
    function test2(name) {
        console.log('my name is ' + name);
    }
    // 将局部变量赋值到module对象上
    module.exports = test2;
    return module.exports;
}

var exported = load(mudule);
// 保存module
save(module, exported);
```

通过把参数`module`传递给`load()`函数，`module_test.js`就顺利地把一个变量传递给了Node执行环境，Node会把`module`变量保存到某个地方。

由于Node保存了所有导入的`module`，当我们用`require()`获取module时，Node找到对应的`module`，把这个`module`的`exports`变量返回，这样，另一个模块就顺利拿到了模块的输出：

```javascript
var test = require('./module_test');
```

